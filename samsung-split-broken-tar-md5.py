#! /usr/bin/python

# Copyright 2013, Oscar Jounaud <oscar.jounaud@gmail.com>
#
# All rights reserved.
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright
#   notice, this list of conditions and the following disclaimer.
# * Redistributions in binary form must reproduce the above copyright
#   notice, this list of conditions and the following disclaimer in the
#   documentation and/or other materials provided with the distribution.
# * Neither the name of the University of California, Berkeley nor the
#   names of its contributors may be used to endorse or promote products
#   derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import struct
import sys
import tarfile
import hashlib
import shutil
import os
from optparse import OptionParser

#  I was not able to let Odin flash official ROM for
#  Samsung GT-S5360 found on
#    http://samsung-updates.com/device/?id=GT-S5360
#  like S5360XXLK3_S5360XEFLL1_S5360XXLK3_HOME.tar.md5
#
#  Those tar.md5 files should be a tar file followed by
#  its MD5 sum, more precisely it can be generated by
#  the following commands:
#    $ tar cf XXX.tar file1 file2 ...
#    $ cp XXX.tar XXX.tar.md5
#    $ md5sum XXX.tar >> XXX.tar.md5
#
#  But those tar.md5 files are corrupted:
#    $ tar tvf XXX.tar.md5
#    tar: This does not look like a tar archive
#    tar: Skipping to next header
#    tar: Exiting with failure status due to previous errors
#
#  Here is the beginning of an hexa dump:
#    $ hd XXX.tar.md5
#    00000000  73 62 6c 2e 62 69 6e 00  00 00 00 00 00 00 00 00  |sbl.bin.........|
#    00000010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
#    *
#    00000070  00 00 00 00 00 00 00 00  00 00 00 00 30 30 30 30  |............0000|
#    00000080  34 37 37 30 30 30 30 00  00 00 00 00 00 00 00 00  |4770000.........|
#    00000090  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
#    *
#    00000200  13 00 00 ea fe ff ff ea  fe ff ff ea fe ff ff ea  |................|
#    00000210  fe ff ff ea fe ff ff ea  f8 f0 9f e5 fe ff ff ea  |................|
#    00000220  04 e0 4e e2 ff 5f 2d e9  0a 03 a0 e3 0d 00 50 e1  |..N.._-.......P.|
#    00000230  07 00 00 ca 76 6a 00 eb  0a 03 a0 e3 0d 00 50 e1  |....vj........P.|
#
#  There is a 512-byte header record, followed by file contents.  A
#  normal header record contains many informations, but here there are
#  only the file name (sbl.bin in the example above) and its length
#  (4770000 in octal, i.e. 1306624 bytes).
#
#  This script uses these informations to extract files, and generated
#  the 3 tar.md5 files needed by Odin.

parser = OptionParser(usage="samsung-split-broken-tar-md5.py <official-tar.md5>\n\
Extract files from a single archive and creates 3 archive files usable by Odin",
    prog="samsung-split-broken-tar-md5")
parser.add_option("-k", "--keep", action="store_true", dest="keep",
    help="keep intermediate files")
(options, args) = parser.parse_args(args=sys.argv[1:])

if len(args) != 1:
    parser.print_usage()
    sys.exit(1)

struct_header = struct.Struct("124s11s377s") #  name, size (in octal), padding; size=512

temp_files = []
with open(args[0], "rb") as file:
    while True:
        header = file.read(512)
        if len(header) < 512: break
        s = struct_header.unpack_from(header)
        name = s[0]
        pos = name.index('\0')
        if pos >= 0: name = name[0:pos]

        length = int(s[1], 8)
        print("Extract %s, file length=%d" % (name, length))
        buf = file.read(length)
        out = open(name, "wb")
        out.write(buf)
        out.close()
        temp_files.append(name)

def write_tar(name, files):
    print("Write file %s" % name)
    tf = tarfile.open(name, mode='w', format=tarfile.USTAR_FORMAT)
    for f in files: tf.add(f)
    tf.close()
    with open(name, "rb") as file:
        buf = file.read()
    print("Rename %s into %s.md5 and compute checksum" % (name, name))
    shutil.copyfile(name, name+".md5")
    with open(name+".md5", "ab") as file:
        file.write(hashlib.md5(buf).hexdigest())
        file.write('  ')
        file.write(name)
        file.write('\n')
        temp_files.append(name)

write_tar("CSC.tar",      ['csc.rfs'])
write_tar("MODEM-CP.tar", ['BcmCP.img'])
write_tar("PDA-AP.tar",   ['boot.img', 'param.lfs', 'system.img', 'sbl.bin'])

if not options.keep:
    print("Remove intermediate files: %s" % temp_files)
    for x in temp_files: os.remove(x)

